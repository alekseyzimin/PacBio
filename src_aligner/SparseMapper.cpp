#include "iostream"
#include "stdio.h"
#include "string"
#include "vector"
#include "cstdlib"

#include <map>
#include <math.h>
#include "memory"
#include <algorithm>
#include <fstream>
#include "sstream"
#include "list"
#include "stdlib.h"
#include "time.h"
#include <stdint.h>

#include "BasicDataStructure.h"
#include "GraphConstruction.h"
#include "Query.h"
#include "Alignment.h"


using namespace std;



int main(int argc, char* argv[])
{
	cout<<"Example command:"<<endl;
	cout<<"SparseMapper k 17 g 16 r Ref.fa q Qry1.fa q Qry2.fa"<<endl;
	cout<<"Parameters:"<<endl;
	cout<<"k: kmer size, support 11~31."<<endl;
	cout<<"g: number of skipped intermediate k-mers, support 1-25."<<endl;
	cout<<"SA: 1 use suffix array instead of k-mer."<<endl;
	cout<<"aln: 1:output alignment results. 0: just mapping."<<endl;
	cout<<"rep: 0: skip ambiguous matches. 1: map even the matches are ambiguous."<<endl;
	cout<<"QS: Raw quality score file generated by our base calling algorithm."<<endl;
	cout<<"MaxLen: Trim to this length."<<endl;

	size_t hashTableSZ=1000000;
	int gap=0;
	uint64_t GenomeSize=0,totReads=0;
	uint64_t tot_bases=0;
	
	int K_size=31,mismatch=1;
	bool BUILD_GRAPH=1;
	int error_cnt[300];
	int base_cnt[300];
	int subs_matrix[4][4];
	int subs_matrices[350][4][4];

	map<int,int> errors_nreads;
	list<int> unmapped_reads,unmapped_or_indel_reads;
	list<string> unmapped_tags;
	memset(subs_matrix,0,sizeof(int)*16);
	map<char,int> char_int;
	char_int['A']=0;
	char_int['C']=1;
	char_int['G']=2;
	char_int['T']=3;
	int NoIndelMatches=0,nInsertions=0,nDeletions=0,nIndelReads=0;
	bool AlnStats=1;
	int TrimN=1;
	bool Compress=0;
	memset(error_cnt,0,sizeof(int)*300);
	memset(base_cnt,0,sizeof(int)*300);

	ofstream o_log("MappingLog.txt");
	ofstream o_error_rates("ErrorRates.txt");
	ofstream o_unmapped("UnmappedLog.txt");
	ofstream o_unmapped_or_indel("Unmapped_or_Indel_Log.txt");
	int ExpCov=0;
	//parameters for the bloom filter
	bool Bloom=0,KmerTable=0,LOAD_GRAPH=0,aln=1,rep=0,Clust=0,SurArr=0,match_kmers_only=0;
	int Bloom_d=-1,HighCovTh=1000,MaxLen=50000,MinLen=500;
	double ErrorRate=0.15;
	double BF_FalsePositive=0.001;
	double two=2;
	string ref_filename,qry_filename,QS_File;
	vector<string> qry_filename_vt;
	QS_File.clear();
	for(int i=1;i<argc;++i)
	{
		if(strcmp(argv[i],"k")==0)
		{
			i++;
			K_size=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"R")==0)
		{
			i++;
			totReads=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"g")==0)
		{
			i++;
			gap=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"TrimN")==0)
		{
			i++;
			TrimN=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"Compress")==0)
		{
			i++;
			Compress=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"rep")==0)
		{
			i++;
			rep=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"MatchKmersOnly")==0)
		{
			i++;
			match_kmers_only=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"HighCovTh")==0)
		{
			i++;
			HighCovTh=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"KmerTable")==0)
		{
			i++;
			KmerTable=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"LD")==0)
		{
			i++;
			LOAD_GRAPH=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"MaxLen")==0)
		{
			i++;
			MaxLen=atoi(argv[i]);
			continue;
		}

		if(strcmp(argv[i],"r")==0)
		{
			i++;

			ref_filename=(argv[i]);
			
			continue;
		}
		if(strcmp(argv[i],"q")==0)
		{
			i++;
			qry_filename=(argv[i]);
			qry_filename_vt.push_back(qry_filename);
			continue;
		}
		if(strcmp(argv[i],"aln")==0)
		{
			i++;
			aln=atoi(argv[i]);
			continue;
		}
		if(strcmp(argv[i],"e")==0)
		{
			i++;

			mismatch=atoi(argv[i]);
			
			continue;
		}
		if(strcmp(argv[i],"BF")==0)
		{
			i++;
			Bloom=atoi(argv[i]);
			continue;
		}

		if(strcmp(argv[i],"Bloom_d")==0)
		{
			i++;
			Bloom_d=atoi(argv[i]);
			continue;
		}

		if(strcmp(argv[i],"QS")==0)
		{
			i++;
			QS_File=(argv[i]);
			continue;
		}


	}

	for(int i=0;i<MaxLen;++i)
	{
		//memset(subs_matrices[i],0,sizeof(int)*16);
	}

	time_t beg_time,read_time;
	time(&beg_time);

	struct ref_t ref;
	
	string ref_str;
	uint64_t End_Pos=0;
	int n_frags=0;
	int N_count=0;
	string frag;
	string tag,n_tag,seq;
	uint64_t ref_pos=0,ref_sz=0,num_reads=0;
	size_t max_readlen=0;
	
	vector<size_t> frag_sz_vt; 
	map<string,int> tag_map;
	vector<string> tag_vt;
	vector<int> seq_len_vt;
	ofstream o_ref_info("Ref_info.txt");
	ofstream o_align_info("Map_info.txt");
	
	double max_qs=0.0,min_qs=1.0;
	vector<double> qs_vt;
	int len=0;
	ifstream in_QS;
	int nBins=101;
	map<int,int> bCounts,bErrors;

	if(!Clust)
	{

		cout<<"Reading reference file..."<<endl;
		
		ifstream fasta_in(ref_filename.c_str());
		num_reads=0;
		while(get_a_fasta_read( fasta_in, tag, seq, n_tag))
		{
			//build the graph progressively
			if(Compress)
			{
				string_shrinkage(seq);
			}
			size_t frag_sz=seq.size();
			frag_sz_vt.push_back(frag_sz);
			ref_sz+=frag_sz;
			if(frag_sz>max_readlen)
			{
				max_readlen=frag_sz;
			}
			num_reads++;
			n_frags++;
			//if(num_reads>10)
			//{break;}
		}
		fasta_in.clear();
		fasta_in.close();
		num_reads=0;

	
		ref.ref_seq.read_bits=(uint64_t *) malloc((size_t) (max_readlen/4)+100);
		ref.ref_seq.alloc_sz=(size_t)(max_readlen/4+100);
		ref_str.clear();
		ref_str.reserve(max_readlen+100);
		fasta_in.open(ref_filename.c_str());
		ref_pos=0,num_reads=0;

		/*
		num_reads=0;
		while(get_a_fasta_read( fasta_in, tag, seq, n_tag))
		{
			if(Compress)
			{
				string_shrinkage(seq);
			}
			int seq_sz=seq.size();	
			int k=0;
			for(int i=0;i<seq_sz;i=k)
			{

				if(i>=seq_sz-1)
				{break;}
				while(seq[i]=='N'&&(i<=seq_sz-1))
				{++i;}
				if(i>=(seq_sz-K_size+1))
				{break;}
				while((seq[i]!='A'&&seq[i]!='C'&&seq[i]!='G'&&seq[i]!='T')&&(i<=seq_sz-K_size))
				{++i;}
			
				for (k=i+1;k<seq_sz;++k)
				{
					if((seq[k]!='A'&&seq[k]!='C'&&seq[k]!='G'&&seq[k]!='T'))
					{break;}
				}			
				string frag=seq.substr(i,k-i);
				ref_str=ref_str+frag;
				n_frags++;
				End_Pos+=frag.size();
				ref.FragEnds[End_Pos]=n_frags;

			}
			num_reads++;
			//if(num_reads>10)
			//{break;}
		}
	
		fasta_in.clear();
		fasta_in.close();
		//Init_Ref_Read(ref_str,ref.ref_seq);
		ref_str.clear();
		num_reads=0;
		ref_pos=0;
		*/
	}
	
		
	struct BF_info BF_info;
	BF_info.Bloom=0;

	if (Bloom)
	{

		uint64_t KmerEstNo=End_Pos;
		
		//uint64_t KmerEstNo=(uint64_t) (((double)(GenomeSize*Coverage*(AvgLen-K_size+1)/AvgLen))*(1-pow((1-ErrorRate),K_size))+GenomeSize);

		BF_info.m=(uint64_t) (((double)KmerEstNo/gap)*(-log(BF_FalsePositive)/log(two)/log(two))+100);		
		BF_info.BF_HT=(uint8_t *)calloc(BF_info.m/8+10,sizeof(uint8_t));
		BF_info.d=min(max((int)(7*(BF_info.m)/KmerEstNo/10+0.5),2),2);
		if(Bloom_d>0)
		{	
			BF_info.d=Bloom_d;
		}

		BF_info.Bloom=1;
		
	}


	o_ref_info<<"Total reference length: "<<ref_sz<<endl;
	o_ref_info<<"Max reference length: "<<max_readlen<<endl;
	o_ref_info<<"Reference count: "<<num_reads<<endl;
	cout<<"Total fragments: "<<n_frags<<endl;
	//cout<<"Fragments length: "<<End_Pos<<endl;
	o_ref_info<<"Total fragments: "<<n_frags<<endl;
	o_ref_info<<"Fragments length: "<<End_Pos<<endl;


	//Initialize hashtables
	//ref_sz=End_Pos;

	uint64_t ht_sz_tmp= ref_sz/max(gap-2,5);
	if(ht_sz_tmp>((size_t) -1) )
	{
		cout<<"Problem scale too large. Reduce reference size."<<endl;
		return -1;

	}

	hashTableSZ=(size_t) ht_sz_tmp;
	struct hashtable ht;
	struct hashtable2 ht2;
	

	if(K_size<=32)
	{
		Init_HT(&ht,hashTableSZ);
	}
	else
	{
		;
	}


	int64_t bucket_count=0,edge_cnt=0;

	time(&read_time);
	cout<<difftime(read_time,beg_time)<<" secs."<<endl;

	cout<<"Processing reference file..."<<endl;


	struct ref_read_t ref_read;
	ref_read.read_bits=(uint64_t *) malloc(max_readlen/4+100);
	ref_read.alloc_sz=max_readlen/4+100;
	
	map<string,int> key_map;

//	map<uint64_t,int> key_map;
	//vector<int> ref_read_len_vt;
	vector<string> ref_tags;
	if(!SurArr)//sparse k-mer based
	{
		bucket_count=0;
		for(int round=1;round<=2;round++)
		{
			//bucket_count=0;
			cout<<"Round "<<round<<". Building the sparse k-mer reference graph."<<endl;
			ref_pos=0;
			num_reads=0;
			
			ifstream fasta_in;//(ref_filename.c_str());
			if(!Clust)
			{
				fasta_in.open(ref_filename.c_str());
			}
			else
			{
				fasta_in.open(qry_filename.c_str());
			}
			ref_read.read_idx=0;
			while(get_a_fasta_read( fasta_in, tag, seq, n_tag))
			{
				ref_tags.push_back(tag);
				ref_read.read_idx++;
				if(Compress)
				{
					string_shrinkage(seq);
				}
				//seq.resize(50);
				//build the graph progressively,2 rounds
				int frag_sz=seq.size();
		
				//build now

				int k=0;

				int seq_sz=seq.size();	

				for(int i=0;i<seq_sz;i=k)
				{

					if(i>=seq_sz-1)
					{break;}
					while(seq[i]=='N'&&(i<=seq_sz-1))
					{++i;}
					if(i>=(seq_sz-K_size+1))
					{break;}
					while((seq[i]!='A'&&seq[i]!='C'&&seq[i]!='G'&&seq[i]!='T')&&(i<=seq_sz-K_size))
					{++i;}
			
					for (k=i+1;k<seq_sz;++k)
					{
						if((seq[k]!='A'&&seq[k]!='C'&&seq[k]!='G'&&seq[k]!='T'))
						{break;}
					}			
					string frag=seq.substr(i,k-i);

					if(frag.size()<=K_size)
					{continue;}
					Init_Ref_Read(frag,ref_read);
					if(Clust)
					{
						ref_pos=num_reads;
					}

					//cout<<num_reads<<endl;
					//if(num_reads==10)
					//{cout<<"";}
					Sparse_Kmer_Ref_Graph_Construction(&ref_read,&ht,&bucket_count,&edge_cnt, K_size,gap,&BF_info,round,ref_pos,&ref);//,key_map);
					
					ref_pos+=frag.size();
					
				}

				if(round==2)
				{
					ref.ref_read_len_vt[ref_read.read_idx]=seq_sz;
				}

				num_reads++;
				//if(num_reads>10)
				//{break;}

			}
			cout<<bucket_count<<" nodes."<<endl;
			if(round==1)
			{
				ref.ref_read_len_vt.resize(num_reads+1);
			}
			fasta_in.clear();
			fasta_in.close();

			if(round==1)
			{
				if(K_size<=32)
				{	cout<<"Memory used: "<<(sizeof(struct bucket_r1)*bucket_count)/1024/1024<<" MB."<<endl;}
				else
				{
					;
				}
			}
			else
			{
				if(K_size<=32)
				cout<<"Memory used: "<<(sizeof(struct bucket)*bucket_count+sizeof(struct edge_node)*edge_cnt)/1024/1024<<" MB."<<endl;
				else
				{
					;
				}


			}

			if(round==1)
			{
				//free BF
				if(Bloom)
				{
					//free(BF_info.BF_HT);
				}

				if(K_size<=64)
				{
				
					SwitchBuckets(&ht,&ht2,K_size);
				}
				else
				{
					;
				}
			}
			if(round==1)
			{
				if(K_size<=32)
				{
					for(size_t i=0;i<ht.ht_sz;++i)
					{				
						struct bucket* bktptr=ht.store_pos[i];
						while(bktptr!=NULL)
						{
							bktptr->kmer_info.cov1=0;	
							bktptr=bktptr->nxt_bucket;
						}
					
					}
				
				}
				else
				{
					;
				}

				ref.repeat_maps.reserve(bucket_count/100);
				ref.repeat_cnt=0;
			}

			time(&read_time);
			cout<<difftime(read_time,beg_time)<<" secs."<<endl;

		}
	
	}
	else
	{
		//suffix array
		

	}

	o_log<<bucket_count<<" nodes."<<endl;	
	if(ref.repeat_cnt>0)
	{ref.repeat_cnt--;}
	if(!Bloom)
	{
		cout<<ref.repeat_cnt<<" repeating nodes."<<endl;
		o_log<<ref.repeat_cnt<<" repeating nodes."<<endl;
	}
	//cout<<"Memory for repeating nodes: "<<sizeof(ref.repeat_maps)/1024/1024<<" MB."<<endl;
	

	//int map_match=0;
	if(!Clust)
	{
		int Reads_with_Ns=0;
		int tot_Ns=0;
		int tot_kmers=0;
		int matching_kmers=0;
		cout<<"Processing query file(s)..."<<endl;
		ofstream out_ref_matched("Mapped.fasta");
		ofstream out_ref_aligned("Aligned.fasta");
		ofstream out_overlap_interval("Interval_full.txt");
		ofstream out_overlap_interval_csv("Interval_full.csv");
		ofstream out_overlap_interval_selected("Interval.txt");
		ofstream out_overlap_interval_csv_selected("Interval.csv");

		
		out_overlap_interval_csv<<"tag,";
		out_overlap_interval_csv<<"orientation,";
		out_overlap_interval_csv<<" pb_coordinate_(full_sr),";//<<endl;
		out_overlap_interval_csv<<" pb_coordinate__(matched),";//<<endl;
		out_overlap_interval_csv<<" sr_coordinate,";
		out_overlap_interval_csv<<" matching_bases,";
		out_overlap_interval_csv<<" k-mers,";
		out_overlap_interval_csv<<" consecutive_k-mers, "<<endl;

		out_overlap_interval_csv_selected<<"tag,";
		out_overlap_interval_csv_selected<<"orientation,";
		out_overlap_interval_csv_selected<<" pb_coordinate_(full_sr),";//<<endl;
		out_overlap_interval_csv_selected<<" pb_coordinate__(matched),";//<<endl;
		out_overlap_interval_csv_selected<<" sr_coordinate,";
		out_overlap_interval_csv_selected<<" matching_bases,";
		out_overlap_interval_csv_selected<<" k-mers,";
		out_overlap_interval_csv_selected<<" consecutive_k-mers, "<<endl;


		uint64_t n_query=0,matched=0;

		if(!QS_File.empty())
		{
			in_QS.open(QS_File.c_str());
		}

		for(int i=0;i<qry_filename_vt.size();++i)
		{
			cout<<"File: "<<qry_filename_vt[i]<<endl;
			ifstream reads_in(qry_filename_vt[i].c_str());
			string tag,n_tag,qs,temp;
			bool fq_flag=0;
			size_t nq=0;
			if(getline(reads_in,temp))
			{
				if(temp.size()==0)
				{
					continue;
				}
				else
				{
					if(temp[0]=='@')
					{
						fq_flag=1;
					}
					if(temp[0]!='@'&&temp[0]!='>')
					{continue;}
				}
			}
			reads_in.clear();
			reads_in.close();
			reads_in.open(qry_filename_vt[i].c_str());

			bool read_success=0;
			
			while(1)
			{
				if(n_query%10000==0)
				{cout<<n_query<<endl;}

				n_query++;
				nq++;
			
				if((n_query>totReads)&&(totReads!=0))
				{break;}
				
				if(n_query%10000000==0)
				{
					cout<<n_query<<" queries."<<endl;
					time(&read_time);
					cout<<difftime(read_time,beg_time)<<" secs."<<endl;
				}

				if(fq_flag)
				{
					read_success=get_a_fastq_read(reads_in,tag,seq,qs);
					if(Compress)
					{
						string_shrinkage(seq);
					}
				}
				else
				{
					read_success=get_a_fasta_read(reads_in,tag,seq,n_tag);
					if(Compress)
					{
						string_shrinkage(seq);
					}
				}
//				cout<<seq<<endl;
				if(!QS_File.empty())
				{

					get_a_qs_read(in_QS, len, qs_vt);

				}

				if(read_success==0)
				{
					break;
				}

				int seq_sz=strlen(seq.c_str());

				if(seq_sz<MinLen)
				{
					continue;
				}
				if(seq_sz>MaxLen)
				{
					seq.resize(MaxLen);
					//cout<<"Sequence too long, skipped."<<endl;
					//continue;
					seq_sz=MaxLen;
				}
				bool N_flag=0;
				int N_counts=0;
				for(int i=0;i<seq_sz;++i)
				{
					if(seq[i]=='N')
					{N_flag=1;N_counts++;}
				}
				if(N_flag)
				{
					//Reads_with_Ns++;continue;
				}
//				tot_Ns+=N_counts;
//				if(tot_Ns>0)
				//cout<<tot_Ns<<endl;

				if(N_counts>=TrimN)
				{
					Reads_with_Ns++;
					continue;
				}
				
				bool bad_flag=0;
						
				int nN=seq_sz-1,isN=-1;
				for(int i=0;i<seq_sz;++i)
				{
						
					if(seq[i]=='-'||seq[i]=='N')
					{
						if(i<=seq_sz/2)
						{
							isN=i;
							continue;
						}
						else
						{
							nN=i-1;
							break;
						}
					}
				}
				int s=0;
				if((nN-isN)<=seq_sz/2)
				{
					bad_flag=1;
				}
					
				if(bad_flag==1)
				{
					seq.clear();
					continue;
				}

				if(isN>=0)
				{
					for(int i=isN+1;i<=nN;++i)
					{
						seq[s]=seq[i];
						s++;
					}
					seq[s]='\0';
					seq.resize(s);
				}
					
				seq_sz=seq.size();

				read_t read;
				Init_Read(seq,read);
				memcpy(read.tag,tag.c_str(),tag.size());
				read.read_idx=n_query;
				struct qry_ret qry_ret;
				if(aln)
				{
					qry_ret.align=1;
				}
				else
				{
					qry_ret.align=0;
				}
				if(rep)
				{
					qry_ret.repeat=1;
				}
				else
				{
					qry_ret.repeat=0;
				}

				if(match_kmers_only)
				{
					qry_ret.match_kmers_only=1;
				}
				else
				{
					qry_ret.match_kmers_only=0;
				}

				qry_ret.tot_kmers=read.readLen-K_size+1;
				qry_ret.matching_kmers=0;
				if(match_kmers_only)
				{
					qry_ret.ret_seq=seq;
					for(int s=0;s<qry_ret.ret_seq.size();++s)
					{
						qry_ret.ret_seq[s]=tolower(qry_ret.ret_seq[s]);
					}
				}
				//Sparse_Kmer_Ref_Graph_Query(&ref, &read,&ht,K_size,gap, &qry_ret);//,key_map,map_match);
				Sparse_Kmer_Ref_Graph_Query_LR(&ref, &read,&ht,K_size,gap, &qry_ret);//,key_map,map_match);
				if(match_kmers_only)
				{
					matching_kmers+=qry_ret.matching_kmers;
					tot_kmers+=qry_ret.tot_kmers;
					if(tag[0]=='@')
					{tag[0]='>';}

					out_ref_matched<<tag<<": ";

					/*
					o_align_info<<tag<<": ";
					

					for (int rr=0;rr!=qry_ret.ordered_read_pos.size();++rr)
					{
						vector<int64_t> reads_pos_vt=qry_ret.ordered_read_pos[rr];
						for (int ss=0;ss!=reads_pos_vt.size();ss+=2)
						{
							o_align_info<<"(" << reads_pos_vt[ss]<<"): "<<reads_pos_vt[ss+1]<<", ";
						}
						o_align_info<<endl;

					}
					
					o_align_info<<endl;
					
					*/
					

					out_ref_matched<<endl;
					out_ref_matched<<qry_ret.ret_seq<<endl;

					
					map<int,vector<int> > beg_read,end_read;
					
					for (map<int,vector<int> >::iterator reads_map_it=qry_ret.match_ref_read_beg.begin();reads_map_it!=qry_ret.match_ref_read_beg.end();++reads_map_it)
					{
						if(reads_map_it->second.size()<10||qry_ret.match_stats[reads_map_it->first][4]<4)
						{continue;}
						vector<int>::iterator  reads_pos_it1=reads_map_it->second.begin(),reads_pos_it2=reads_map_it->second.end();
						int sum=0;
						while(reads_pos_it1!=reads_pos_it2)
						{
							sum+=*reads_pos_it1;
							reads_pos_it1++;
						}
						sum/=(int)(reads_map_it->second.size());
						
						//beg_read[sum].push_back(reads_map_it->first);//sorted by the avg first matching position
						beg_read[qry_ret.match_stats[reads_map_it->first][5]].push_back(reads_map_it->first);//sorted by the first matching position
					}

					

					for (map<int,vector<int> >::iterator reads_map_it=qry_ret.match_ref_read_end.begin();reads_map_it!=qry_ret.match_ref_read_end.end();++reads_map_it)
					{
						if(reads_map_it->second.size()<10||qry_ret.match_stats[reads_map_it->first][4]<4)
						{continue;}
						vector<int>::iterator  reads_pos_it1=reads_map_it->second.begin(),reads_pos_it2=reads_map_it->second.end();
						int sum=0;
						while(reads_pos_it1!=reads_pos_it2)
						{
							sum+=*reads_pos_it1;
							reads_pos_it1++;
						}
						sum/=(int)(reads_map_it->second.size());
						
						//end_read[reads_map_it->first].push_back(sum);
						//end_read[reads_map_it->first].push_back(reads_map_it->second.size());
						
						end_read[reads_map_it->first].push_back(qry_ret.match_stats[reads_map_it->first][6]);
					}

					out_overlap_interval<<tag<<": "<<endl;
					out_overlap_interval_csv<<tag<<": "<<endl;
					out_overlap_interval_selected<<tag<<": "<<endl;
					out_overlap_interval_csv_selected<<tag<<": "<<endl;

					for (map<int,vector<int> >::iterator reads_map_it=beg_read.begin();reads_map_it!=beg_read.end();++reads_map_it)
					{
						vector<int>::iterator  reads_pos_it1=reads_map_it->second.begin(),reads_pos_it2=reads_map_it->second.end();
						int last_cod=-1000;
						while(reads_pos_it1!=reads_pos_it2)
						{
							//out_overlap_interval<<"read "<<*reads_pos_it1<<" --Placement: ["<<reads_map_it->first<<", "<<end_read[*reads_pos_it1][0]<<"],";//<<endl;
							
							string tag_temp=ref_tags[abs(*reads_pos_it1)-1];
							out_overlap_interval<<ref_tags[abs(*reads_pos_it1)-1];
							out_overlap_interval_csv<<ref_tags[abs(*reads_pos_it1)-1]<<",";
							
							if(qry_ret.match_stats[*reads_pos_it1][6]>last_cod)
							{last_cod=qry_ret.match_stats[*reads_pos_it1][6];}
								
							if(*reads_pos_it1>0)
							{
								out_overlap_interval<<" (+)";
								
								out_overlap_interval_csv<<" +,";
							}
							else
							{
								out_overlap_interval<<" (-)";
								
								out_overlap_interval_csv<<" -,";
							}
								
							out_overlap_interval<<	" --pb cod (full sr): ["<<reads_map_it->first<<", "<<end_read[*reads_pos_it1][0]<<"],";//<<endl;
							out_overlap_interval<<	" --pb cod (matched): ["<<qry_ret.match_stats[*reads_pos_it1][5] <<", "<<qry_ret.match_stats[*reads_pos_it1][6]<<"],";//<<endl;
							out_overlap_interval<<" --sr cod: ["<<qry_ret.match_stats[*reads_pos_it1][0]<<", "<<qry_ret.match_stats[*reads_pos_it1][1]<<"],";//<<endl;
							out_overlap_interval<<" --matching bases: " <<qry_ret.match_stats[*reads_pos_it1][2]<<", ";//<<endl;
							out_overlap_interval<<" --k-mers: " <<qry_ret.match_stats[*reads_pos_it1][3]<<", ";
							out_overlap_interval<<" --consecutive k-mers: " <<qry_ret.match_stats[*reads_pos_it1][4]<<";"<<endl;

							out_overlap_interval_csv<<" ["<<reads_map_it->first<<" "<<end_read[*reads_pos_it1][0]<<"],";//<<endl;
							out_overlap_interval_csv<<" ["<<qry_ret.match_stats[*reads_pos_it1][5] <<" "<<qry_ret.match_stats[*reads_pos_it1][6]<<"],";//<<endl;
							out_overlap_interval_csv<<" ["<<qry_ret.match_stats[*reads_pos_it1][0]<<" "<<qry_ret.match_stats[*reads_pos_it1][1]<<"],";//<<endl;
							out_overlap_interval_csv<<" " <<qry_ret.match_stats[*reads_pos_it1][2]<<",";//<<endl;
							out_overlap_interval_csv<<" " <<qry_ret.match_stats[*reads_pos_it1][3]<<",";
							out_overlap_interval_csv<<" " <<qry_ret.match_stats[*reads_pos_it1][4]<<","<<endl;

							reads_pos_it1++;
						}








						reads_pos_it1=reads_map_it->second.begin();
						reads_pos_it2=reads_map_it->second.end();

						while(reads_pos_it1!=reads_pos_it2)
						{
							if(qry_ret.match_stats[*reads_pos_it1][6]==last_cod)
							{
								string tag_temp=ref_tags[abs(*reads_pos_it1)-1];
								out_overlap_interval_selected<<ref_tags[abs(*reads_pos_it1)-1];
								out_overlap_interval_csv_selected<<ref_tags[abs(*reads_pos_it1)-1]<<",";
							
								
								if(*reads_pos_it1>0)
								{
									out_overlap_interval_selected<<" (+)";
								
									out_overlap_interval_csv_selected<<" +,";
								}
								else
								{
									out_overlap_interval_selected<<" (-)";
								
									out_overlap_interval_csv_selected<<" -,";
								}
								
								out_overlap_interval_selected<<	" --pb cod (full sr): ["<<reads_map_it->first<<", "<<end_read[*reads_pos_it1][0]<<"],";//<<endl;
								out_overlap_interval_selected<<	" --pb cod (matched): ["<<qry_ret.match_stats[*reads_pos_it1][5] <<", "<<qry_ret.match_stats[*reads_pos_it1][6]<<"],";//<<endl;
								out_overlap_interval_selected<<" --sr cod: ["<<qry_ret.match_stats[*reads_pos_it1][0]<<", "<<qry_ret.match_stats[*reads_pos_it1][1]<<"],";//<<endl;
								out_overlap_interval_selected<<" --matching bases: " <<qry_ret.match_stats[*reads_pos_it1][2]<<", ";//<<endl;
								out_overlap_interval_selected<<" --k-mers: " <<qry_ret.match_stats[*reads_pos_it1][3]<<", ";
								out_overlap_interval_selected<<" --consecutive k-mers: " <<qry_ret.match_stats[*reads_pos_it1][4]<<";"<<endl;

								out_overlap_interval_csv_selected<<" ["<<reads_map_it->first<<" "<<end_read[*reads_pos_it1][0]<<"],";//<<endl;
								out_overlap_interval_csv_selected<<" ["<<qry_ret.match_stats[*reads_pos_it1][5] <<" "<<qry_ret.match_stats[*reads_pos_it1][6]<<"],";//<<endl;
								out_overlap_interval_csv_selected<<" ["<<qry_ret.match_stats[*reads_pos_it1][0]<<" "<<qry_ret.match_stats[*reads_pos_it1][1]<<"],";//<<endl;
								out_overlap_interval_csv_selected<<" " <<qry_ret.match_stats[*reads_pos_it1][2]<<",";//<<endl;
								out_overlap_interval_csv_selected<<" " <<qry_ret.match_stats[*reads_pos_it1][3]<<",";
								out_overlap_interval_csv_selected<<" " <<qry_ret.match_stats[*reads_pos_it1][4]<<","<<endl;

								
							}
							reads_pos_it1++;
						}
						
					}


					continue;
				}
				
			}
			n_query--;
			cout<<"reads: "<<(--nq)<<endl;

		
		}

		cout<<"Matching k-mers:"<<matching_kmers<<endl;
		cout<<"Total k-mers:"<<tot_kmers<<endl;

		cout<<Reads_with_Ns<<" reads with Ns skipped."<<endl;
		cout<<"Totoal Ns: "<<tot_Ns<<endl;
		cout<<matched<<" matched."<<endl;
		cout<<NoIndelMatches<<" matched with no indels."<<endl;
		cout<<n_query<<" queries."<<endl;
		cout<<"Reads with indels: "<<nIndelReads<<endl;
		cout<<"Avg insertions: "<<(double)nInsertions/(double) nIndelReads<<endl;
		cout<<"Avg deletions: "<<(double)nDeletions/(double)nIndelReads<<endl;
										
		time(&read_time);
		cout<<difftime(read_time,beg_time)<<" secs."<<endl;

		o_log<<"Matching k-mers:"<<matching_kmers<<endl;
		o_log<<"Total k-mers:"<<tot_kmers<<endl;

		o_log<<Reads_with_Ns<<" reads with Ns skipped."<<endl;
		o_log<<"Totoal Ns: "<<tot_Ns<<endl;
		o_log<<matched<<" matched."<<endl;
		o_log<<NoIndelMatches<<" matched with no indels."<<endl;
		o_log<<"Reads with indels: "<<nIndelReads<<endl;
		o_log<<"Avg insertions: "<<(double)nInsertions/(double)nIndelReads<<endl;
		o_log<<"Avg deletions: "<<(double)nDeletions/(double)nIndelReads<<endl;
		map<int,int>::iterator mit=errors_nreads.begin();
		for(mit=errors_nreads.begin();mit!=errors_nreads.end();++mit)
		{
			o_log<<"Reads with "<<mit->first<<" errors: "<<mit->second<<endl;
		}


		o_log<<n_query<<" queries."<<endl;
		double n_errors=0,tot_cnts=0;
		

		

		
	}
	
	
	o_log<<difftime(read_time,beg_time)<<" secs."<<endl;
	

	
	return 0;
}

