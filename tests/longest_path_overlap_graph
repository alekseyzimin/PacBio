#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case bundling);
use FindBin;
use lib "$FindBin::RealBin";
use UnionFind;

my ($no_header, $help);
my $min_sr = 2; # Minimum # of super read in a mega read
my $min_density = 0.1;
GetOptions("m|min=i"     => \$min_sr,
           "d|density=f" => \$min_density,
           "H|no-header" => \$no_header,
           "h|help"      => \$help) or die;

if(defined($help)) {
  print(<<EOS);
Find the longest (with most k-mers) path in the super-read overlap graph

 -m,--min        Minimum number of super reads in a mega read ($min_sr)
 -d,--density    Minimum denity of k-mers ($min_density)
 -H,--no-header  Do not print line headers
 -h,--help       This message
EOS
# ;
exit(0);
}

my @nodes;
my $pacbioName = "";

print("Rstart Rend Nmers Density PB MegaRead\n") unless $no_header;
while(my $line = <STDIN>) {
  chomp ($line);
  my @flds = split (" ", $line);

  if($pacbioName ne $flds[11]) {
    handle_graph(\@nodes, $pacbioName);
    @nodes = ();
    $pacbioName = $flds[11];
  }

  my $id = @nodes;
  my @info = splice(@flds, 0, 13);
  # LPATH -> Number of mers in longest path up to this node. LPREV ->
  # Previous node in longest path. LSTART -> starting node in longest
  # path. LCOUNT -> Number of nodes in longest path.
  push(@nodes, { ID => $id, NAME => $info[12], NMERS => $info[4], NEIGHS => [], INDEG => 0,
                 MINOFFSET => $info[0], MAXOFFSET => $info[1], LEN => $info[10], MERCOUNTS => \@flds ,
                 LPATH => 0, LPREV => undef, LSTART => undef, LCOUNT => 1 });
}
handle_graph(\@nodes, $pacbioName);

# Create the edges between the nodes. Returns the connected
# components.
sub create_edges {
  my ($nodes) = @_;

# An edge is a triplet [v, w, z] where v is the index of
# the id of the node and w is the weight (number of shared mers
# between nodes), and z is the number of shared k-unitigs.
  my $components = UnionFind->new();
  for(my $i=0; $i < @$nodes; ++$i) {
    my $maxOffset = $$nodes[$i]{MAXOFFSET};
    my $super = $$nodes[$i]{NAME};
    my @tflds = split (/_/, $super);
    my $lastKUni = $tflds[-1];
    for (my $j=$i+1; $j < @$nodes; ++$j) {
      last if ($$nodes[$j]{MINOFFSET} >= $maxOffset);
      my $localSuperReadName = $$nodes[$j]{NAME};
      my $index = index ($localSuperReadName, $lastKUni);
      next unless ($index >= 0);
      my $lenOfSubstring = $index + length ($lastKUni);
      my $lastToFind = substr ($super, -$lenOfSubstring);
      $index = index ($localSuperReadName, $lastToFind);
      next unless ($index == 0);
      my @unitigs = split(/_/, $lastToFind); # k-unitigs in common between nodes
      my $mers_shared = 0;
      my $mers_info = $$nodes[$j]{MERCOUNTS};
      for(my $k = 0; $k < @unitigs; ++$k) {
        $mers_shared += $$mers_info[2 * $k];
        $mers_shared -= $$mers_info[2 * $k - 1] if $k > 0;
      }
      push(@{$$nodes[$i]{NEIGHS}}, [$j, $mers_shared, scalar(@unitigs)]);
      $$nodes[$j]{INDEG}++;
      $components->union($i, $j);
    }
  }

  return $components;
}

# Find the longest paths in the graph, for the set of nodes and
# connected components. Returns a hash with for each connected
# component, a reference the the last node of the longest path.
sub find_longest_paths {
  my ($nodes, $components) = @_;
# One longest path per weakly connected component. Reference to
# terminal node of path.
  my %longest_paths;

# The nodes have been created in topological order, because the
# coordinates are sorted according to PacBIO read position. So we can
# find the longest path by visiting each node in order once.
  foreach my $v (@$nodes) {
    # Bootstrap for starting nodes
    if($$v{INDEG} == 0) {
      $$v{LPATH}  = $$v{NMERS};
      $$v{LSTART} = $v;
    }
    my $cpath = $$v{LPATH};

    # Record longest path for ending nodes
    if(@{$$v{NEIGHS}} == 0) {
      my $comp = $components->find($$v{ID});
      my $lp   = $longest_paths{$comp};
      $longest_paths{$comp} = $v if !defined($lp) || $cpath > $$lp{LPATH};
      next;
    }
    
    # For interior nodes, updates neighbors
    foreach my $e (@{$$v{NEIGHS}}) {
      my $nv     = $$nodes[$$e[0]];
      my $ncp    = $cpath + $$nv{NMERS} - $$e[1];
      if($ncp > $$nv{LPATH}) {
        $$nv{LPATH}  = $ncp;
        $$nv{LSTART} = $$v{LSTART};
        $$nv{LPREV}  = $v;
        $$nv{LCOUNT} = $$v{LCOUNT} + 1;
      }
    }
  }
  return %longest_paths
}

# Print the longest paths
sub print_longest_paths {
  my ($longest_paths, $pbname) = @_;

  while(my ($comp, $lp) = each %$longest_paths) {
    next if $$lp{LCOUNT} < $min_sr;
    my $lp_ostart = $$lp{LSTART}{MINOFFSET};
    my $lp_oend   = $$lp{MAXOFFSET};
    my $density = $$lp{LPATH} / ($lp_oend - $lp_ostart + 1);
    next if($density < $min_density);

    my @path;
    my $term_node = $lp;
    while(defined($term_node)) {
      push(@path, $term_node);
      $term_node = $$term_node{LPREV};
    }

    printf("%d %d %d %.2g %s ", $lp_ostart, $lp_oend, $$lp{LPATH}, $density, $pbname);

    print($path[-1]{NAME});
    for(my $i = $#path; $i > 0; $i--) {
      my $v = $path[$i];
      foreach my $n (@{$$v{NEIGHS}}) {
        next unless $$n[0] == $path[$i - 1]{ID};
        my $w = $path[$i - 1];
        my @srs = split(/_/, $$w{NAME});
        splice(@srs, 0, $$n[2]);
        print("_", join("_", @srs));
        last;
      }
    }
    print("\n");
  }
}

sub handle_graph {
  my ($nodes, $pbname) = @_;
  return unless @$nodes;
  my $components = create_edges($nodes);
  my %longest_paths = find_longest_paths($nodes, $components);
  print_longest_paths(\%longest_paths, $pbname);
}
