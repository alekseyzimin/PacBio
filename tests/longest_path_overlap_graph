#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case bundling);
use FindBin;
use lib "$FindBin::RealBin";
use UnionFind;
use threads;
use Thread::Queue;

my ($no_header, $compact, $help);
my $nb_threads  = 1;
my $min_sr      = 2; # Minimum # of super read in a mega read
my $min_density = 0.1;
my $output      = "mega_reads";
GetOptions("m|min=i"     => \$min_sr,
           "d|density=f" => \$min_density,
           "H|no-header" => \$no_header,
           "t|thread=i"  => \$nb_threads,
           "o|output=s"  => \$output,
           "c|compact"   => \$compact,
           "h|help"      => \$help) or die;

if(defined($help)) {
  print(<<EOS);
Find the longest (with most k-mers) path in the super-read overlap graph

 -m,--min INT        Minimum number of super reads in a mega read ($min_sr)
 -d,--density FLOAT  Minimum denity of k-mers ($min_density)
 -H,--no-header      Do not print line headers
 -t,--thread INT     Number of threads ($nb_threads)
 -o,--output PATH    Output prefix file ($output)
 -c,--compact        Compact output
 -h,--help           This message
EOS
# ;
exit(0);
}

# Start threads
my $input_queue = Thread::Queue->new();
for(my $i = 0; $i < $nb_threads; $i++) { threads->create(\&thread_main); }

# Read input for worker threads
while(<>) {
  next unless /^>(\d+) (\S+)/;
  my ($nb_lines, $pb) = ($1, $2);
  my @lines :shared;
  for(my $i = 0; $i < $nb_lines; $i++) {
    my $line :shared = <>;
    push(@lines, \$line);
  }
  push(@lines, $pb);
  $input_queue->enqueue(\@lines);
}

# Terminate. Because '$input_queue->end()' does not exists in old
# versions of Perl, we send a sentinel value (an empty array)
foreach my $th (threads->list) { my @sentinel :shared; $input_queue->enqueue(\@sentinel); }
foreach my $th (threads->list) { $th->join; }


sub thread_main {
  my $output_file = $output . "_" . threads->tid();
  open(my $out, ">", $output_file) or die "Can't open output file '$output_file': $!";

  unless($no_header) {
    print($out "Rstart Rend Nmers Density");
    print($out " PB") unless $compact;
    print($out " MegaRead\n") unless $no_header;
  }
  while(my $lines = $input_queue->dequeue) {
    last unless @$lines;
    my $pbName = pop(@$lines);
    my @nodes;
    foreach my $line (@$lines) {
      my @flds = split (" ", $$line);
      my $id = @nodes;
      my @info = splice(@flds, 0, 12);
      # LPATH -> Number of mers in longest path up to this node. LPREV ->
      # Previous node in longest path. LSTART -> starting node in longest
      # path. LCOUNT -> Number of nodes in longest path.
      my $node = { ID => $id, NAME => $info[11], NMERS => $info[4], NEIGHS => [], INDEG => 0,
                   RSTART => $info[0], REND => $info[1], QSTART => $info[2], QEND => $info[3],
                   RLEN => $info[9], QLEN => $info[10], MERCOUNTS => \@flds,
                   LPATH => 0, LPREV => undef, LSTART => undef, LCOUNT => 1 };
      my $imp_start     = $$node{RSTART} - $$node{QSTART} + 1;
      $imp_start        = 1 if $imp_start < 1;
      my $imp_end       = $$node{REND} + $$node{QLEN} - $$node{QEND};
      $imp_end          = $$node{RLEN} if $imp_end > $$node{RLEN};
      $$node{IMP_START} = $imp_start;
      $$node{IMP_END}   = $imp_end;
      push(@nodes, $node);
    }
    @nodes = sort { $$a{IMP_START} <=> $$b{IMP_START} } @nodes;
    handle_graph(\@nodes, $pbName, $out);
  }
  close($out);
}

# Create the edges between the nodes. Returns the connected
# components.
sub create_edges {
  my ($nodes) = @_;

# An edge is a triplet [v, w, z] where v is the index of
# the id of the node and w is the weight (number of shared mers
# between nodes), and z is the number of shared k-unitigs.
  my $components = UnionFind->new();
  for(my $i       = 0; $i < @$nodes; ++$i) {
    my $node_i    = $$nodes[$i];
    my $i_name    = $$node_i{NAME};
    my @tflds     = split (/_/, $i_name);
    my $lastKUni  = $tflds[-1];
    for (my $j=$i+1; $j < @$nodes; ++$j) {
      my $node_j      = $$nodes[$j];
      last if $$node_j{IMP_START} > $$node_i{IMP_END};
      my $j_name = $$node_j{NAME};
      next unless $j_name =~ /(?:^|_)($lastKUni)(?:_|$)/;
      my $common_len     = $+[1];
      my $common_unitigs = substr($i_name, -$common_len);
      next unless $common_unitigs eq substr($j_name, 0, $common_len);
      my @unitigs = split(/_/, $common_unitigs); # k-unitigs in common between nodes
      my $mers_shared = 0;
      my $mers_info = $$node_j{MERCOUNTS};
      for(my $k = 0; $k < @unitigs; ++$k) {
        $mers_shared += $$mers_info[2 * $k];
        $mers_shared -= $$mers_info[2 * $k - 1] if $k > 0;
      }
      push(@{$$node_i{NEIGHS}}, [$j, $mers_shared, scalar(@unitigs)]);
      $$node_j{INDEG}++;
      $components->union($i, $j);
    }
  }

  return $components;
}

# Find the longest paths in the graph, for the set of nodes and
# connected components. Returns a hash with for each connected
# component, a reference the the last node of the longest path.
sub find_longest_paths {
  my ($nodes, $components) = @_;
# One longest path per weakly connected component. Reference to
# terminal node of path.
  my %longest_paths;

# The nodes have been created in topological order, because the
# coordinates are sorted according to PacBIO read position. So we can
# find the longest path by visiting each node in order once.
  foreach my $v (@$nodes) {
    # Bootstrap for starting nodes
    if($$v{INDEG} == 0) {
      $$v{LPATH}  = $$v{NMERS};
      $$v{LSTART} = $v;
    }
    my $cpath = $$v{LPATH};

    # Record longest path for ending nodes
    if(@{$$v{NEIGHS}} == 0) {
      my $comp = $components->find($$v{ID});
      my $lp   = $longest_paths{$comp};
      $longest_paths{$comp} = $v if !defined($lp) || $cpath > $$lp{LPATH};
      next;
    }
    
    # For interior nodes, updates neighbors
    foreach my $e (@{$$v{NEIGHS}}) {
      my $nv     = $$nodes[$$e[0]];
      my $ncp    = $cpath + $$nv{NMERS} - $$e[1];
      if($ncp > $$nv{LPATH}) {
        $$nv{LPATH}  = $ncp;
        $$nv{LSTART} = $$v{LSTART};
        $$nv{LPREV}  = $v;
        $$nv{LCOUNT} = $$v{LCOUNT} + 1;
      }
    }
  }
  return %longest_paths
}

# Print the longest paths
sub print_longest_paths {
  my ($longest_paths, $pbname, $out) = @_;

  print($out ">$pbname\n");
  while(my ($comp, $lp) = each %$longest_paths) {
    next if $$lp{LCOUNT} < $min_sr;
    my $start_n   = $$lp{LSTART};
    my $lp_ostart = $$start_n{RSTART} - $$start_n{QSTART} + 1; # Implied start in PB read
    $lp_ostart    = 1 if $lp_ostart < 1;
    my $lp_oend   = $$lp{REND} + $$lp{QLEN} - $$lp{QEND};
    $lp_oend      = $$lp{RLEN} if $lp_oend > $$lp{RLEN};
    my $density   = $$lp{LPATH} / ($lp_oend - $lp_ostart + 1);
    next if($density < $min_density);

    my @path;
    my $term_node = $lp;
    while(defined($term_node)) {
      push(@path, $term_node);
      $term_node = $$term_node{LPREV};
    }

    printf($out "%d %d %d %.2g ", $lp_ostart, $lp_oend, $$lp{LPATH}, $density);
    print($out "$pbname ") unless($compact);

    print($out $path[-1]{NAME});
    for(my $i = $#path; $i > 0; $i--) {
      my $v = $path[$i];
      foreach my $n (@{$$v{NEIGHS}}) {
        next unless $$n[0] == $path[$i - 1]{ID};
        my $w = $path[$i - 1];
        my @srs = split(/_/, $$w{NAME});
        splice(@srs, 0, $$n[2]);
        print($out "_", join("_", @srs));
        last;
      }
    }
    print($out "\n");
  }
}

sub handle_graph {
  my ($nodes, $pbname, $out) = @_;
  return unless @$nodes;
  my $components = create_edges($nodes);
  my %longest_paths = find_longest_paths($nodes, $components);
  print_longest_paths(\%longest_paths, $pbname, $out);
}
