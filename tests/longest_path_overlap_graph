#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use FindBin;
use lib "$FindBin::RealBin";
use UnionFind;

my ($list_sr, $help);
my $min_sr = 2; # Minimum # of super read in a mega read
my $min_density = 0.1;
GetOptions("l|list" => \$list_sr,
           "m|min=i" => \$min_sr,
           "d|density=f" => \$min_density,
           "h|help" => \$help) or die;

if(defined($help)) {
  print(<<EOS);
Find the longest (with most k-mers) path in the super-read overlap graph

 -m,--min      Minimum number of super reads in a mega read ($min_sr)
 -d,--density  Minimum denity of k-mers ($min_density)
 -l,--list     List the super-reads
 -h,--help     This message
EOS
# ;
exit(0);
}

my (@nodes);
my $pacbioName;

while(my $line = <STDIN>) {
  chomp ($line);
  my @flds = split (" ", $line);
  if (defined ($pacbioName)) {
    if ($flds[11] ne $pacbioName) {
      print "You screwed up! Only use for ONE (1) pacbio read at a time. Bye!\n";
      exit (1); }
  } else {
    $pacbioName = $flds[11];
  }
  my $id = @nodes;
  my @info = splice(@flds, 0, 13);
  push(@nodes, { ID => $id, NAME => $info[12], NMERS => $info[4], NEIGHS => [], LPATH => 0, LPREV => undef, INDEG => 0,
                 MINOFFSET => $info[0], MAXOFFSET => $info[1], LEN => $info[10], MERCOUNTS => \@flds });
}

# A node has { ID => i, NMERS => n, NEIGHS => [], LPATH => length,
# LPREV => prev_node } A edge is a pair [v, w] where v is the index of
# the id of the node and w is the weight (number of shared mers
# between nodes).
my $components = UnionFind->new();
for(my $i=0; $i< @nodes; ++$i) {
  my $maxOffset = $nodes[$i]{MAXOFFSET};
  my $super = $nodes[$i]{NAME};
  my @tflds = split (/_/, $super);
  my $lastKUni = $tflds[-1];
  for (my $j=$i+1; $j< @nodes; ++$j) {
    last if ($nodes[$j]{MINOFFSET} >= $maxOffset);
    my $localSuperReadName = $nodes[$j]{NAME};
    my $index = index ($localSuperReadName, $lastKUni);
    next unless ($index >= 0);
    my $lenOfSubstring = $index + length ($lastKUni);
    my $lastToFind = substr ($super, -$lenOfSubstring);
    $index = index ($localSuperReadName, $lastToFind);
    next unless ($index == 0);
    my @unitigs = split(/_/, $lastToFind); # k-unitigs in common between nodes
    my $mers_shared = 0;
    my $mers_info = $nodes[$j]{MERCOUNTS};
    for(my $k = 0; $k < @unitigs; ++$k) {
      $mers_shared += $$mers_info[2 * $k];
      $mers_shared -= $$mers_info[2 * $k - 1] if $k > 0;
    }
    push(@{$nodes[$i]{NEIGHS}}, [$j, $mers_shared, scalar(@unitigs)]);
    $nodes[$j]{INDEG}++;
    $components->union($i, $j);
  }
}

# One longest path per weakly connected component. Contains { LEN => nmers, OSTART => x, OEND => x TERM => node }
my %longest_path;
sub traverse_tree {
  my ($id, $path_len, $prev) = @_;
  my $v = $nodes[$id];

  return if($path_len < $$v{LPATH});
  $$v{LPATH} = $path_len;
  $$v{LPREV} = $prev;

  my $out_degree = scalar(@{$$v{NEIGHS}});
  if($out_degree == 0) {
    my $comp = $components->find($id);
    my $lp = $longest_path{$comp};
    $lp = $longest_path{$comp} = { LEN => 0, OSTART => $$v{MINOFFSET} } unless defined($lp);
    if($path_len > $$lp{LEN}) {
      $$lp{LEN}  = $path_len;
      $$lp{TERM} = $id;
      $$lp{OEND} = $$v{MAXOFFSET};
    }
    return;
  }

  foreach my $n (@{$$v{NEIGHS}}) {
    my $w = $nodes[$$n[0]];
    traverse_tree($$n[0], $path_len + $$w{NMERS} - $$n[1], $id);
  }
}

foreach my $v (@nodes) {
  if($$v{INDEG} == 0) {
    traverse_tree($$v{ID}, $$v{NMERS}, undef);
  }
}

print("Rstart Rend Nmers Density MegaRead\n");
while(my ($comp, $lp) = each %longest_path) {
  my @path;
  my $term_node = $$lp{TERM};
  while(defined($term_node)) {
    push(@path, $term_node);
    $term_node = $nodes[$term_node]{LPREV};
  }

  next if(@path < $min_sr);
  my $density = $$lp{LEN} / ($$lp{OEND} - $$lp{OSTART} + 1);
  next if($density < $min_density);

  if(defined($list_sr)) {
    for(my $i = $#path; $i >= 0; $i--) {
      print($path[$i], " ", $nodes[$path[$i]]{NAME}, "\n");
    }
  }

  printf("%d %d %d %.2g ", $$lp{OSTART}, $$lp{OEND}, $$lp{LEN}, $density);

  print($nodes[$path[-1]]{NAME});
  for(my $i = $#path; $i > 0; $i--) {
    my $v = $nodes[$path[$i]];
    foreach my $n (@{$$v{NEIGHS}}) {
      next unless $$n[0] == $path[$i - 1];
      my $w = $nodes[$path[$i - 1]];
      my @srs = split(/_/, $$w{NAME});
      splice(@srs, 0, $$n[2]);
      print("_", join("_", @srs));
      last;
    }
  }
  print("\n");
}
